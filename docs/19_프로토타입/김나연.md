# 19. 프로토타입

## 19.5 프로토타입의 생성 시점

### 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성됨
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재

### 사용자 정의 생성자 함수와 프로토타입 생성 시점

```jsx
console.log(Person.prototype); // {constructor: f}

function Person(name) {
	this.name = name;
}
```

![image](https://user-images.githubusercontent.com/72698829/211477822-4aa70408-c873-4019-811a-fe2403387e4b.png)

- 생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성됨
- 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 되고 이때 프로토타입도 더불어 생성됨
- 프로토타입도 객체이고 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 가짐

### 사용자 정의 생성자 함수가 아닌 경우

```jsx
const Person = name => {
	this.name = name;
};

console.log(Person.prototype); // undefined
```

- 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않음
- 화살표 함수나 ES6의 메서드 축약 표현으로 정의하지 않고 일반함수로 정의한 함수 객체는 new 연산자와 함께 생성자 함수로서 호출할 수 있음

### 빌트인 생성자 함수와 프로토타입 생성 시점

![image](https://user-images.githubusercontent.com/72698829/211477851-1e494d5f-bf1d-4fcb-b831-cc4aa07408f8.png)

- Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성됨
- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성됨
- 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재함
- 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당됨

## 19.6 객체 생성 방식과 프로토타입의 결정

### 객체 생성 방법

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### 객체 리터럴에 의해 생성된 객체의 프로토타입

```jsx
const Obj = { x: 1 };

console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x')); // true
```

![image](https://user-images.githubusercontent.com/72698829/211477888-fd241861-070e-4d3d-b555-015303b38f1b.png)

- 자바스크립트 엔진은 객체를 생성할 때 추상 연산 OrdinaryObjectCreate를 호출함
- 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype으로 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype

### Object 생성자 함수에 의해 생성된 객체의 프로토타입

```jsx
const obj = new Object();
obj.x = 1;

console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x')); // true
```

![image](https://user-images.githubusercontent.com/72698829/211477956-9ab30c7a-9dcf-4102-a1c3-37605433dc14.png)

- Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype

### 생성자 함수에 의해 생성된 객체의 프로토타입

```jsx
function Person(name) {
	this.name = name;
}

const me = new Person('Lee');
```
![image](https://user-images.githubusercontent.com/72698829/211477999-3a055c63-0157-40ce-8d78-929f0c0c8671.png)

- new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObjectCreate가 호출됨
- 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
- Object.prototype은 다양한 빌트인 메서드(hasOwnProperty, propertyIsEnumerable 등)을 가지고 있지만 사용자 정의 생성자 함수 Person과 더불어 생성된 프로토타입 Person.prototype의 프로퍼티는 contructor 뿐임

## 19.7 프로토타입 체인

### 프로토타입 체인

```jsx
function Person(name) {
	this.name = name;
}

Person.prototype.sayHello = function () {
	console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');

// hasOwnProperty는 Object.prototype의 메서드다.
console.log(me.hasOwnProperty('name')); // true
```

![image](https://user-images.githubusercontent.com/72698829/211478009-45e7b10f-0c4c-4d0c-93e4-b56b52d821a9.png)

- 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색함
- 프로토타입 체인인 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘임

## 19.8 오버라이딩과 프로퍼터 섀도잉

- 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라 함
- 프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근해야 함

**오버라이딩: 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

**오버로딩: 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 호출하는 방식, 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용해 구현할 수는 있음

# ✨정리

## 프로토타입 생성 시점

- 생성자 함수가 생성되는 시점에 더불어 생성된다.
- 생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성되고 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.

## 객체 생성 방식

- 다양한 방식으로 생성된 모든 객체는 각 방식마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.
- OrdinaryObjectCreate는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달 될 경우 프로퍼티 객체를 추가한다.
- 그 후 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 다음 생성한 객체를 반환한다.

## 객체의 프로토타입

<img src="https://user-images.githubusercontent.com/72698829/211477904-840aa6e7-5936-49d9-99e5-1e9ad5b61498.png" width="33%"><img src="https://user-images.githubusercontent.com/72698829/211477970-0f8aa930-79d9-4ee5-aeef-b38a9084addb.png" width="33%"><img src="https://user-images.githubusercontent.com/72698829/211477983-a7a73c95-3321-4216-9f63-e8685dae0f15.png" width="33%">

- 객체 리터럴을 평가하여 객체를 생성할 때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다.
- Object 생성자 함수를 호출하여 객체를 생성할 때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다.
- new 연산자와 함께 생성자 함수를 호출하여 인스턴스를  생성할 때  추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

## 프로토타입 체인

- 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.
- 프로토타입 체인인 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.
