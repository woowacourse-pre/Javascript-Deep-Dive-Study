# 📂 19장 프로토타입

- 자바스크립트를 이루고 있는 거의 모든 것은 객체

## 19.1 객체지향 프로그래밍
- 여러 개의 독립적인 단위, 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

- 추상화, 속성에 대해 이해해보자
  - 속성 : 특징이나 성질을 나타냄
  - 추상화 : 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것
  - 객체 : 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복잡한 자료구조, 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복잡한 자료구조

```js
// 이름과 주소 속성을 갖는 객체
// person의 다양한 속성 중에 '이름'과 '주소'라는 속성에만 관심이 있어 필요한 속성만 추출하여 표현한 것을 추상화
const person = {
  // 상태 데이터 => 프로퍼티(property)
  name: 'minsun',
  address: 'Seoul', 

  // 동작 => 메서드(method)
  sayHello() {
    return 'Hello, ' + this.name
  }
};

console.log(person.sayHello()) // Hello, minsun
};

console.log(person); // {name: 'minsun', address: 'Seoul'}
```
## 19.2 상속과 프로토타입
### 상속?
- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용

- 왜 상속하나요?
  - 불필요한 코드 중복을 제거하고 기존의 코드를 재사용하기 위함.
  - 코드 재사용시 개발 비용을 줄일 수 있음.

```js
// 생성자 함수
function Circle(r) {
  this.r = rl
  this.getArea = function () {
    return Math.PI * this.r ** 2;
  };
}

// 반지름이 1인 인스턴스 생성 
const circle1 = new Circle(1);
// 반지름이 2인 인스턴스 생성 
const circle1 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // flase
```
> console.log(circle1.getArea === circle2.getArea)
- circle1은 r 프로퍼티와 getArea 메서드를 가짐
- circle2은 r 프로퍼티와 getArea 메서드를 가짐
- circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메서드를 중복으로 생성하고 모든 인스턴스가 중복 소유됨.
- 각자의 getArea 메서드를 생성하게 됨. 
  - 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는것은 메모리 낭비! 개수가 더 많아 진다면 더 최악!
  - => 상속을 통해 불필요한 중복을 제거하자

```js
function Circle(r) {
  this.r = r;
}

// Circle 유전자에 getArea 메서드를 추가.
// 프로토타입은 Circle 생성자 함수의 prototype 프로터피에 바인딩되어 있음.
Circle.prototype.getArea = function () {
  return Math.PI * r * 2;
};

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // True
```
> console.log(circle1.getArea === circle2.getArea); // True

- Circle.prototpye으로 상속 받은 getArea를 circle1과 circle2가 공유하기 때문에 하나의 getArea 메서드를 가리킴.

- 상속의 좋은 점
  - 자신의 상태를 나타내는 r 프로퍼티만 개별적 소유하고 동일한 메서드를 상속을 통해 공유하여 사용하므로 코드의 재사용성에서 매우 유용
  - 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해두면 별도의 구현 없이 상속을 통해 공유하거나 사용할 수 있음.

## 19.3 프로토타입의 객체
- 모든 객체는 하나의 \[[Prototype]]내부 슬롯을 가짐.
- 내부 슬롯의 값은 프로토타입의 참조임. 하지만 직접 접근 X
- 모든 프로토타입은 생성자 함수와 연결되어 있음.
- 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 \[[Prototype]]에 저장됨.

### 프로토타입의 간접적으로 접근 __proto__
- __proto__ 접근자 프로퍼티 : \[[Prototype]] 내부 슬롯에 간접적을 접근 가능
![객체의프로퍼티](%EA%B0%9D%EC%B2%B4%EC%9D%98%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0.PNG)

## 19.5 프로토타입의 생성 시점
- 프로토타입은 생성자 함수가 생성되는 시점에 생성됨.
- 생성자 함수 : 사용자 정의 생성자 함수, 빌트인 생성자 함수

### 사용자 정의 생성자 함수의 프로토타입 생성 시점
- 화살표 함수나 ES6의 메서드 축약 표현으로 정의한 함수는 호출할 수 없는 함수임
  - non-constructor는 프로토타입이 생성되지 않음.
- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성
- 생성된 프로토타입의 프로토타입은 언제나 Object.prototype임.

```js
//함수호이스팅에 의해 함수가 정의되고 더불어 프로토타입이 생성
console.log(Person.prototype)

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

### 빌트인 생성자 함수의 프로토타입 생성 시점
- 전역 객체가 생성되는 시점
- 생성된 프로토타입은 빌트인 생성자 함수의 prototpye 프로퍼티에 바인딩됨.

## 19.6 객체 생성 방식과 프로토타입의 결정
- 객체 생성 방법
  1. 객체 리터럴 
  2. Object 생성자 함수
  3. 생성자 함수
  4. Object.create 메서드
  5. 클래스(ES6)

###  객체 리터럴 프로토타입의 결정
- 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype임.

```js
const obj = { x: 1}; // 객체 리터럴 내부에 프로퍼티 추가

// obj객체가 Object.prototype 객체를 상속 받았기 때문에
// obj는 constructor과 hasOwnProperty 메서드를 소유하지 않지만 자신의 프로토타입인 constructor과 hasOwnProperty 메서드를 자유롭게 사용 가능.
console.log(obj.constructor === Object); // True
console.log(obj.hasOwnProerty('x')); // True
```

### Object 생성자 함수 프로토타입의 결정
- Object 생성자 함ㅅ에 의해 생성되는 객체의 프로토타입은 Object.prototype임.

```js
const obj = new Object(); // 빈 객체를 생성한 이후
obj.x = 1; // 프로퍼티 추가

console.log(obj.constructor === Object); // True
console.log(obj.hasOwnProerty('x')); // True
```

###  생성자 함수 프로토타입의 결정
- 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체임.

```js
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
```
- 사용자 정의 함수 Person과 더불어 생성된 Person.prototype의 프로퍼티는 constructor뿐이다.
- Object 생성자 함수에 의해 생성된 Object.prototype은 다양한 메서드(hasOwnProperty, proertyIsEnumerable 등)을 가짐.

## 19.7 프로토타입 체인
- 프로토타입 체인 : 객체의 프로퍼티에 접근하려고 할때 해당 객체에 프로퍼티가 없다면 \[[Prototype]] 내부 슬롯 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 검색하는 것
  - 나한테 없으면 나의 부모님에게 있냐고 물어봄
- 프로토타입 체인의 최상위는 항상 Object.prototype
- Object.prototype의 프로토타입은?
  - null 
- 만약 Object.prototype에도 없다면 undefined를 반환함.
  
## 19.8 오버라이딩과 프로퍼티 섀도잉

```js
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }
  
  // 프로토타입 메서드 => 프로퍼티 섀도우
  Person.prototype.sayHello = function () {
    console.log(`Hi, ${this.name}`)
  };

  // 생성자 함수 반환
  return Person
}());

// 인스턴스 me 생성
const me = new Person('Lee')

// 인스턴스에 프로토 타입 프로퍼티와 동일한 이름의 메서드 추가 => 오버라이딩
me.sayHello = function () {
  console.log(`Hi, ${this.name}`)
};

me.sayHello(); // Hi, Lee
```
- 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 덮어쓰임이 아니라 추가가 됨.
- 인스턴스 메서드 sayHello는 프로토타입 메서드 sayHello를 오버라이딩 했고, 프로토타입 메서드 sayHello는 프로퍼티 섀도잉이 됨.

- 삭제도 마찬가지
  - 하지만 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제는 불가능하고 프로토타입에 직접 접근해서 해야함.

```js
delete me.sayHello; // 인스턴스 메서드 sayHello 삭제
me.sayHello(); // Hi, Lee

delete me.sayHello; // 프로토타입 메서드 sayHello 삭제
// 삭제되지 않고 호출됨
me.sayHello(); // Hi, Lee

// 프로토타입 체인에 의해 삭제하지 말고 직접 접근해서 삭제해야함.
delete Person.prototype.sayHello;
me.sayHello();// TypeError: me.sayHello is not a function
```



## 느낀점

- 이번 19장은 정리하지 못했다. 지금까지 파트를 정리하면서 가장 어려웠던 부분인거 같다. 1일째는 그냥 읽으면서 중간 중간 궁금한 용어를 검색하다가 몇 시간이 갔고 2일째 간단하게 표현한 그림을 이해하려고 노력했다. 하지만 내가 이해했다고, 남들에게 설명할 수 있는 부분은 아래의 프로토타입 목적이다. 추가적인 내용을 다시 학습하여 정리해야겠다.

- "그래서 도대체 프로토타입이 뭔데? " 
  - '애플코딩'의 강사님께서는 '유전자' 라고 표현하신다. 이 파트를 읽으면서 가장 도움이 되었던 비유였다.
  - 만약 스파이더맨처럼 거미줄을 발사하는 능력이 유전된다면, 나는 거미줄을 발사하는 능력을 가지기 위해 내가 연마하는 것이 아니라 엄마에게 그 유전자가 있는지 확인하고 있으면 나도 쓰면 되는 것이다. 그렇다면 내가 그 능력을 가지기 위해 할 노력을 하지 않아도 되는 것이다. 
    - => ***상속을 통해 불필요한 코드 중복을 제거하는 것*** 프로토 타입의 목적이라 생각한다.

