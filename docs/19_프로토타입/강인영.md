## 19.5 프로토타입의 생성 시점

- 리터럴 표기법에 의해 생성된 객체도 생성자 함수(constructor)와 연결됨.

> 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로, 결국 모든 객체는 생성자 함수와 연결되어 있다.
> 

> **Prototype**은 생성자 함수가 생성되는 시점에 같이 생성된다.
> 
- **생성자 함수**는
    - 사용자 정의 생성자 함수와,
    - JavaScript가 기본 제공하는 빌트인 생성자 함수로 구분된다.

### 19.5.1 사용자 정의 생성자 함수와 Prototype 생성 시점

> 생성자 함수로서 호출할 수 있는 함수, 즉 `constructor`는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 Prototype도 더불어 생성됨.
> 

> 생성자 함수로서 호출할 수 없는 함수, 즉 **non-constructor**는 Prototype이 생성되지 않음.
> 
- 함수 선언문은 런타임 이전에 JS 엔진에 의해 먼저 실행됨.
    - 따라서 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 됨.
    - 이 때 **Prototype** 도 더불어 생성됨.
- 즉, **사용자 정의 생성자 함수**는 자신이 평가되어 함수 객체로 생성되는 시점에 Prototype도 더불어 생성되며, 생성된 Prototype은 `Object.prototype` 임.

```jsx
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
console.log(Person.prototype); // {constructor: ƒ}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

```jsx
// 화살표 함수는 non-constructor다.
const Person = name => {
  this.name = name;
};

// non-constructor는 프로토타입이 생성되지 않는다.
console.log(Person.prototype); // undefined
```

### 19.5.2 빌트인 생성자 함수와 Prototype 생성 시점

- Prototype 생성 시점은 사용자 정의 생성자 함수와 동일함.
- 함수가 생성되는 시점에 **Prototype** 이 생성되기 때문임.

> 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 생성된 Prototype은 빌트인 생성자 함수의 **prototype property**에 바인딩됨.
> 
- 전역 객체: 코드 실행 전 JS 엔진에 의해 생성되는 특수한 객체
- 객체가 생성되기 이전에 생성자 함수와 prototype 은 이미 객체화되어 존재함. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 prototype은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당됨

## 19.6 객체 생성 방식과 프로토타입의 결정

- 객체 생성 방식
    - 객체 리터럴
    
    ```jsx
    const obj = { x: 1 };
    ```
    
    ```jsx
    const obj = { x: 1 };
    
    // 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
    console.log(obj.constructor === Object); // true
    console.log(obj.hasOwnProperty('x'));    // true
    ```
    
    - Object 생성자 함수
    
    ```jsx
    const obj = new Object();
    obj.x = 1;
    ```
    
    ```jsx
    const obj = new Object();
    obj.x = 1;
    
    // Object 생성자 함수에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
    console.log(obj.constructor === Object); // true
    console.log(obj.hasOwnProperty('x'));    // true
    ```
    
    - 생성자 함수
    
    ```jsx
    function Person(name) {
      this.name = name;
    }
    
    const me = new Person('Lee');
    ```
    
    - Object.create 메서드
    - 클래스(ES6)
- 각 방식마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 `OrdinaryObjectCreate`에 의해 생성된다는 공통점이 있음.

- **객체 리터럴** vs **Object 생성자 함수**에 의한 객체 생성 방식 차이
    - property를 추가하는 방식만 다름.
    - 두 방식 모두 `Object.prototype`을 상속받는 것이 공통점.
    - **객체 리터럴**은 객체 리터럴 내부에 property를 추가하지만, **Object 생성자 함수**는 우선 빈 객체를 생성한 후 property를 추가해야 함.

## 19.7 프로토타입 체인

- **Prototype Chain**
    - JS가 **객체지향 프로그래밍의 상속**을 구현하는 메커니즘
    - JS는 객체의 property에 접근하려고 할 때 해당 객체에 접근하려는 property가 없다면, [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 prototype의 property를 순차적으로 검색함.
    - Prototype의 종점: **Object.prototype**
- **Prototype Chain vs Scope Chain**
    - Prototype Chain은 상속과 property 검색을 위한 메커니즘
    - Scope Chain은 식별자 검색을 위한 메커니즘
    - 두 가지가 서로 협력하여 식별자와 property를 검색하는데 사용됨.
- `me.hasOwnProperty('name')` → 먼저 Scope Chain에서 **me 식별자**를 검색 → 전역에서 선언되었으므로 **전역 Scope**에서 검색되며, me 식별자를 검색한 다음, **me 객체의 Prototype Chain**에서 `hasOwnProperty` 메서드를 검색한다.

```jsx
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');

// hasOwnProperty는 Object.prototype의 메서드다.
console.log(me.hasOwnProperty('name')); // true
```

- 위 코드에서 Person 생성자 함수에 의해 생성된 me 객체는, Object.prototype의 메서드인 hasOwnProperty를 호출할 수 있음.
- 이는 me 객체가 Person.prototype뿐만 아니라 **Object.prototype** 도 상속 받았음을 의미함. (me 객체의 prototype은 Person.protoype임!!)

```jsx
Object.getPrototypeOf(me) === Person.prototype; // -> true
```

- Person.prototype의 프로토타입은 Object.prototype이다.

```jsx
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
```

- Prototype의 Prototype은 언제나 Object.prototype 이다.

## 19.8 오버라이딩과 프로퍼티 섀도잉

- `Prototype property` : Prototype이 소유한 property
- `Instance property` : Instance가 소유한 property
- Prototype property와 같은 이름의 property를 Instance에 추가하면, prototype chain을 따라 prototype property를 검색 → prototype property를 덮어쓰는 것이 아니라 **Instance property로 추가**함.
- **`Overriding`**: 상위 class가 가지고 있는 메서드를 하위 class가 재정의하여 사용하는 방식
- `**Property Shadowing**`: 상속 관계에 의해 property가 가려지는 현상
- Property 삭제
    - 하위 객체를 통해 prototype property를 변경, 삭제하는 것은 불가능
    - 하위 객체를 통해 prototpye에 get 액세스는 허용, but set은 불가.
    - prototype property를 변경, 삭제하려면 **하위 객체를 통해 prototype chain**으로 접근하는 것이 아니라 **prototype에 직접 접근**해야 함.

```jsx
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee');

// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`); // 오버라이딩
};

// 인스턴스 메서드가 호출된다. 
// 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is Lee
```

---

### 느낀 점

- 프로토타입의 개념도 아직 익숙해지지 않았는데, 프로토타입의 프로퍼티부터 시작해서 프로토타입 생성 시점, 오버라이딩, 그리고 프로퍼티 섀도잉까지.. 정말 많은 개념과 메커니즘을 한꺼번에 이해하려고 하니 쉽지 않았다.
- 이 모든 것을 이해하기 위해서는 여러번 읽어봐야 할 듯. (이 책은 몇회독은 해야 감이 온다고 한다..😂)